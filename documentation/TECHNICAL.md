**WD-XL 滑油字 | WD-XL Lubrifont**

# 技术解析 Technical Tidbits 技術解析

> 以下随手笔记仅以简体中文与英文解释，请见谅。  
> The following short notes are explained in Chinese (Simplified) and English only.  
> 以下隨手筆記僅以簡體中文與英文解釋，請見諒。

## 绘画字形 Drawing the glyphs

本字体的汉字宽度为 765，字身框为 <0 855 765 -145>，字面框锁定在 <49 814 716 -104> （左极值、上极值、右极值、下极值）。汉字圆角半径多数是 30 或 35，方框右下带有 45° 切角（若左边有拐弯但右边没有时则切左边），切角时腰边（宽、高）的切值为 70，底边（最长）的切值约为 99。最宽的笔画粗细是94。  
The Chinese characters in this font has a width of 765, the em-box is set at <0 855 765 -145>, the character face bounding box is set at <49 814 716 -104> (xMin, yMin, xMax, yMax). Most rounded corners have a radius of 30 or 35, all square box has a 45° cut at the bottom right (if bottom left has a turn but right does not then cut the left); when cutting the triangle, the side legs (width, height) has a length of 70, and the base (longest side) has a length of around 99. The thickest stroke width is 94.

从 2.100 版起，以上字身、字面框皆编码在文种基线表（`BASE`）内。字身框的宽、高度（及其一半）也同时设置在几个空白字符的 **宽度** 以代表字体的各种 em/en 值。`emspace`（U+2003、同时是 `ideographicspace` U+3000）使用字身框的宽度 765，排版时可与汉字排列规整；`enspace`（U+2002） 使用字身框的宽度一半 382。`emquad`（U+2001）则是使用字身框的高度 1000；`enquad`（U+2000）使用字身框高度的一半 500。  
The bounding box values above are encoded in the `BASE`line table starting from v2.100. The width and height of em-box (and its half en) are also set in the font through setting the **advance width** of various spaces. `emspace` (U+2003, also `ideographicspace` U+3000) represents the em-width of 765, which allows it to typeset in a grid with other Chinese hanzi; `enspace` (U+2002) represents half of em-width at 382. `emquad` (U+2001) represents the em-height of 1000; `enquad` (U+2000) represents half of em-height at 500.

本字体的西文是变宽的，上下极值约为 <710 -220> （上极值、下极值），x 高度为 485。西文半径多为 40，切角时腰边（宽、高）的切值为 73，底边（最长）的切值约为 103。最宽的笔画粗细是92。  
The Latin characters in this font is proportional width, the vertical bounding range is <-220 710> (yMin, yMax), x height is 485. Rounded corners have a radius of 40; when cutting the triangle, the side legs (width, height) has a length of 73, and the base (longest side) has a length of around 103. The thickest stroke width is 92.

> 以上数值多为参考使用。  
> Values above are for reference only.

## 准备字体 Preparing the source fonts

本字体使用 FontLab 7 制作，1.0 版本是直接将导出的字体文件当成完成品发布，2.0 版本则正式开始使用 AFDKO 进行封装。但是即使如此，字体源文件 `HuaYou-Regular.vfc` 还是没有太大差异。在制作时，FontLab 可以设置多个母版，而导出时可以分层导出。  
This font is made in FontLab 7, v1.0 uses the font file generated by FontLab directly as the relese font, v2.0 officially uses AFDKO to build the font. Even with the changes in release method, the source font file `HuaYou-Regular.vfc` did not require major changes.

1.0 版导出设置使用 FontLab 预设的 OpenType TT 设置导出，源文件则是使用预设的 UFO Package 导出。默认源文件储存的资讯是 SC 版本，导出 TC 版前需要在 Tables 窗口下把字体名称改成 TC 版本，Features 窗口的一部分给 SC 用的直排标点功能需要删除，再把 Font Info 内的 Codepages 删除 936 简体中文，加上 950 繁体中文。  
In v1.0, the released font uses the export preset "OpenType TT" profile in FontLab, and the source files are exported using the preset "UFO Package" profile. The default information stored in the source file is for SC version, before exporting TC version the name entries are required to be changed to TC version in Tables windows, some part of code for vertical typesetting in SC have to be removed, and the Codepages in Font Info is changed from 936 Simplified Chinese to 950 Traditional Chinese.

2.0 版时为了加速合并过程，在导出前将每个母版层都加上空白字符，确保没有切换字形的字符皆是空白层。如果不想加上空白字符而是要直接导出的话，在合并字体时 `merge-font.py` 的 `is_override_only = ` 则设成 False，程序将会手动比对两个字体文件之间的字符是否一样，耗时较长。导出时，需要基于预设 OpenType TT 设置，将 Outlines 下的所有打勾取消（例如 Remove overlaps，Nodes at extremes，Clean up）以避免两个字体导出时出现不一样的简化运算而把同样字形收录两次。  
In v2.0, to speed up the merging process, before exporting, all glyphs are added empty layers for every master layers, ensuring glyphs that do not require switching has an empty layer in place. If adding empty glyph layers is not desired and just want to directly export all layers out, then when merging the `is_override_only = ` option must be put to False in `merge-font.py`, and the code will manually compare the glyphs between thw two fonts to see if they are the same, requiring longer time. When exporting, changes must be made to the preset "OpenType TT" profile, removing all checkboxes under Outlines (e.g. Remove overlaps, Nodes at extremes, Clean up) to avoid exporting two fonts with slightly different points due to simplify/clean up calculations and resulting in copying the same glyph twice.

## 制作简繁转换代码 Writing `smpl`/`trad` code

作为测试，本字体实现了 OpenType 功能下定义的简繁转换功能，即 `smpl` 和 `trad`。`smpl` 定义了繁体转简体（或日文旧字体转新字体），而 `trad` 定义了简体转繁体（或日文新字体转旧字体）。相关代码存放在 `sources/smpl-trad-conv` 文件夹内。  
As a testing font, this font has implement Simplified/Traditional Chinese conversion feature as defined in OpenType feature, which is `smpl` and `trad`. `smpl` defines conversion from Traditional to Simplified Chinese (or Japanese kyūjitai to shinjitai), while `trad` defines conversion from Simplified to Traditional Chinese (or Japanese shinjitai to kyūjitai). The related code is stored in `sources/smpl-trad-conv`.

此功能首先需要简繁**单字**转换码表，这里采用的是维基百科的转换码表 (https://phabricator.wikimedia.org/source/mediawiki/browse/master/includes/languages/data/ZhConversion.php) 制作了简繁各别的一对一和一对多映射，分别是 `sc-tc-1-1.txt`、`sc-tc-1-m.txt`、`tc-sc-1-1.txt` 和 `tc-sc-1-m.txt`。运行前需要把 `opentype-generate.py` 或 `csv-generate.py` 的 `font-source` 文件路径改成字体内的汉字列表的 TXT 文本档。`opentype-generate.py` 生成的代码可以直接复制进 FontLab 也就是 1.0 版的使用方式，`csv-generate.py` 的则是给 2.0 版为了区分 SC/TC 字形而给 `split_simp_trad.py`/`split_simp_trad_cid.py` 使用，可以特别区分 SC 和 TC 的转换对象。（带 `cid` 的 Python 文件名是将字体转换成 CID 键后使用的）   
This feature requires **single character** conversion table, ans we use the conversion table in Wikipedia (https://phabricator.wikimedia.org/source/mediawiki/browse/master/includes/languages/data/ZhConversion.php) to make one-to-one and one-to-many mapping files, which are `sc-tc-1-1.txt`, `sc-tc-1-m.txt`, `tc-sc-1-1.txt` and `tc-sc-1-m.txt`. Before running `opentype-generate.py` or `csv-generate.py`, the `font-source` file path need to be changed to a text file containing Chinese characters that are in a given font. Feature code generated by `opentype-generate.py` can be copied into FontLab directly which is how it is used in v1.0, files generated by `csv-generate.py` are used for v2.0 to separate SC/TC version using `split_simp_trad.py`/`split_simp_trad_cid.py`, which will cange the mapping glyph for SC and TC. (Python code file name with `cid` is used after converting the font to CID-keyed)

## 合并字体 Merging the fonts （v2.000 版）

本字体采用两个（实际上是三个）地域字体合并成一个集中的字形库后再按需求映射至 Unicode，让一个字形库可以用在两个地域字体且添加了一个字体就能切换两个字形的功能。预想的流程伪代码存在 `makeotf_from2font.txt`，历时一年后终于实践出来了。  
This font uses 2 (actually 3) regional glyphs and merge them into a central glyph database and then map to Unicode as required, allowing the same glyph database to be used for two regional font while allowing glyph changes in the same font. The pseudocode for the program is saved in `makeotf_from2font.txt`, finally realised after one year.

`merge_font.py` 是主要代码，比较字体的字型使用的是 `ttx` 程序导出字形方便进行比对。`ttx` 是一个把字体文件转成人类可读格式，即 XML 文本的工具；相似的工具有 `otfcc`，转换出来的格式是 JSON 文本。合并时，同一码位但有两个不同字形的汉字会放在连续位置，而两个码位但同样字形则暂不处理（未来可能修改）。  
`merge_font.py` is the main code, using `ttx` program to export the glyphs in both font and compare.`ttx` is a tool to convert font files into human readable format, in this case it's XML; similar tols include `otfcc` the exports JSON. When merging, characters on same Unicode but having two different regional glyph are placed consecutively, but two characters sharing the same glyphs are not checked (might be updated in future).

本字体其实受 Zero 子的协助，加入了第三个区域：日文/JP，但因为本字体没有计划支援日文，因此我选择单独合并在字体后面而不调用这些字形（约 700 个）。目前所加入的字形是依据 JIS83 制作，未来可能制作 JP 版本。  
This font receives help from Zero 子 to include a third region: JP, but since Japanese support wasn't planned in this font, so the glyphs are appended at the end of font but no features will be able to use these glyphs (~700 glyphs). Currently glyphs added in are made for JIS83, and JP version is possible in future.

`merge_font.py` 生成的文件如下（按代码内生成顺序）：  
Files generated by `merge_font.py` are as follow (according to time generated by code):

* 各个字体的 XML 解析
* HuaYou-base.ttx
* AI0_HuaYou.txt *(关于 CID 键排序的资料都存在这里 All information about CID key are stored here)*
* map_HuaYou.txt
* cmap_SC.txt
* cmap_TC.txt
* feature_gsub_SC_to_TC.fea
* feature_gsub_TC_to_SC.fea
* convert_SC_TC.txt
* convert_SC_JP.txt
* HuaYou.ttx

需要预先准备的文件如下（按代码使用顺序）：  
Files that are prepared beforehand (according to order used in code):

* WD-XLLubrifont-(region).ttf
* huayou-override-name.txt *(可选 optional)*
* huayou-override-uni.txt *(可选 optional)*

完成运行 `merge_font.py` 后，需要把 `HuaYou-base.ttx` 模板下面加上新生成的字体 `HuaYou.ttx` 保存成 `HuaYou-src.ttx`，再使用 `ttx` 把文本文件转回字体文件 `HuaYou-src.ttf`，合并部分就告一段落。  
When finished running `merge_font.py`, `HuaYou.ttx` is merged into the template file `HuaYou-base.ttx` and save as `HuaYou-src.ttx`, and lastly converting the text file back to font file `HuaYou-src.ttf` will end this section.

## 合并字体 Merging the fonts （v2.001 版）

2.001 版本里，本字体受到 ZERO 子（[@Skr-ZERO](https://github.com/Skr-ZERO)）的鼎力协助，完成了基本的日文字形支援，如 JIS90 和 JIS2004（上一版加入了部分 JIS83 字形）。字体合并的代码新存在 `merge_font_use_mergeFonts.py`，不再直接生成 XML 字体文件，而是选用 `mergeFonts` 把每个地区字形都提取出来后，再合并成一个字体；这个字体可以在接下来的流程使用（`font.pfa`）。  
In version 2.001, this font has accepted help from [@Skr-ZERO](https://github.com/Skr-ZERO) to support basic Japanese orthography such as JIS90 and JIS2004 (last version added some JIS83 glyph). The code to merge the fonts is now at `merge_font_use_mergeFonts.py` and does not generate a new XML font file, instead choose to use `mergeFonts` to extract the regional glyphs, and then merge in a new font; the generated font file can then be used for the next step (`font.pfa`).

`merge_font_use_mergeFonts.py` 生成的文件如下（按代码内生成顺序）：  
Files generated by `merge_font_use_mergeFonts.py` are as follow (according to time generated by code):

* 各个字体的 XML 解析
* AI0_HuaYou.txt *(关于 CID 键排序的资料都存在这里 All information about CID key are stored here)*
* map_HuaYou.txt
* cmap_SC.txt
* cmap_TC.txt
* cmap_JP90.txt
* cmap_JP04.txt
* feature_gsub_to_SC.fea
* feature_gsub_to_TC.fea
* feature_gsub_to_JP83.fea
* feature_gsub_to_JP90.fea
* feature_gsub_to_JP04.fea
* map_SC.txt
* map_TC.txt
* map_JP83.txt
* map_JP90.txt
* map_JP04.txt
* comparison_HuaYou.txt

需要预先准备的文件如下（按代码使用顺序）：  
Files that are prepared beforehand (according to order used in code):

* WD-XLLubrifont-(region).ttf
* huayou-override-name.txt *(可选 optional)*
* huayou-override-uni.txt *(可选 optional)*
* jp90-override.txt *(可选 optional)*
* jp04-override.txt *(可选 optional)*

完成后，首先提取字体的向量图，使用以下指令：  
When completed, the vector glyph diagrams are extracted using the following commands:

* `tx -t1 .\WD-XLLubrifont-Regular.ttf tempfont_SC.pfa`
* `tx -t1 .\WD-XLLubrifont-Trad.ttf tempfont_TC.pfa`
* `tx -t1 .\WD-XLLubrifont-JP83.ttf tempfont_JP83.pfa`
* `tx -t1 .\WD-XLLubrifont-JP90.ttf tempfont_JP90.pfa`
* `tx -t1 .\WD-XLLubrifont-JP04.ttf tempfont_JP04.pfa`

其中，`-t1` 提示软件只提出字形图而已，不提取其他字体资讯， 第二个参数是原本的字体文件名，第三个参数是提取后导出的文件名。  
`-t1` parameter specify the program to extract glyph diagrams only and not other font information, the second parameter is the original font file name, the third parameter is the file name after extracting the font.

之后，再用以下指令，把每个字体字形都按来源重新命名，再合并成一个字体字源 `font.pfa` 给下一步使用。  
After that, the following command is used to rename the glyphs from the font files based on the source region, and then merged into a single font source file `font.pfa` for the next step.

`mergeFonts font.pfa map_SC.txt tempfont_SC.pfa map_TC.txt tempfont_TC.pfa map_JP83.txt tempfont_JP83.pfa map_JP90.txt tempfont_JP90.pfa map_JP04.txt tempfont_JP04.pfa`

这里的第一个参数是导出的文件名 `font.pfa`，接下来的参数两两一组，`map_(地区).txt` 存放重新命名字形的列表，`tempfont_(地区).pfa` 是上一步提取的字形图文件。`map_(地区).txt` 格式如下：  
The first parameter is the file name when exporting the font `font.pfa`, the next few parameters are group in pairs of twos, `map_(region).txt` store the list of glyphs to be renamed, `tempfont_(region).pfa` is the extracted font glyph file from the last step. The format of `map_(region).txt` is as follow:

```
mergeFonts
新名称  原名称
new_name   orig_name
uni4E00-SC  uni4E00
```

## 封装字体 Making the final font

### 转换文件使用 CID 名 Converting files to CID name

在上一步合并完毕后，我们已经将每个字形都对应了一个编号，即 CID 编号，可在 `AI0_HuaYou.txt` 或 `map_HuaYou.txt` 内查询。因为最终的字体功能代码（如 OpenType）需要最后会使用的 CID，因此我们需要将预先写好的功能从字形名转成使用 CID。预先写好的功能是 `HuaYou-feature-main.fea` （参考了 1.0 版），而把功能转成 CID 名的是 `fea_convert_name2cid.py`，生成的文件是 `HuaYou-feature-CID.fea`。  
When we complete the merging in the above step, we have mapped every glyph with a unique ID, which is the CID ordering code and can be checked in `AI0_HuaYou.txt` or `map_HuaYou.txt`. As the final font file feature codes (such as OpenType) requires the final CID ordering name, thus we need to convert the prewritten feature from using glyph names into using CID. Prewritten feature codes are in `HuaYou-feature-main.fea` (used in v1.0), and the program to convert the name is `fea_convert_name2cid.py` which generates a file `HuaYou-feature-CID.fea`.

另外，Unicode 提供了异体字选择器（VS），而设置 VS 也需要使用最终的 CID，因此使用 Python 代码 `UVS_parser.py` 将 VS 表 `UVS_sequence` 转成 `UVS_sequence_CID`。  
Also, Unicode provides Variantion Selectors (VS), and setting up VS requires the final CID, thus using Python code `UVS_parser.py` to convert the VS table `UVS_sequence` to `UVS_sequence_CID`.

简繁转换 `smpl` 和 `trad` 根据上文使用 `split_simp_trad_cid.py` 制作即可。  
Simplified/Traditional conversion feature `smpl` and `trad` uses the code `split_simp_trad_cid.py` mentioned in the section above.

### 准备封装文件 Preparing files for making font

`cmap_SC.txt` 和 `cmap_TC.txt` 需要符合格式，因此将 `cmap.raw` 内以下部分替换成两个 TXT 文件的内容即可。  
`cmap_SC.txt` and `cmap_TC.txt` are required to change the format, and thus we replace the section below in `cmap.raw` into the two TXT files.

```
0 begincidchar
==INSERT HERE==
endcidchar
```

以下是预先准备的字体相关文件：  
Below are prepared files related to font:

* cidfontinfo-SC
* cidfontinfo-TC
* cmap.raw
* feature_SC.fea
* feature_TC.fea
* FontMenuNameDB
* HuaYou-feature-main.fea *(需转换成 CID 键 Need to convert to CID-keyed)*
* HuaYou-feature-template.fea  *(`feature_SC.fea` 和 `feature_TC.fea` 的参考模板，实际没有使用 Template for `feature_SC.fea` and `feature_TC.fea`, not used when building)*
* UVS_sequence *(需转换成 CID 键 Need to convert to CID-keyed)*

以下是代码生成的文件：  
Below are files generated by programs:

* feature_gsub_SC_to_TC.fea
* feature_gsub_TC_to_SC.fea
* feature-ot-simp-to-trad-split.fea
* feature-ot-trad-to-simp-split.fea
* HuaYou-feature-CID.fea
* UVS_sequence_CID

## 封装字体 Building the font

以下按顺序解说使用的文件和功能。以下使用 SC 版说明示范。  
The following discussion will explain the files and their uses. Sample here uses the SC version to demonstrate.

1. `tx -t1 HuaYou-src.ttf font.pfa`

### v2.000

此步将 `HuaYou-src.ttf` 的字形资讯与对应的字形名单独抽取出来存在 `font.pfa`。  
This step extracts glyph information with their names in `HuaYou-src.ttf` out and save in `font.pfa`.

### v2.001

使用上面“合并字体 Merging the fonts （v2.001 版）”的流程制作 `font.pfa`。  
Use the steps above in "合并字体 Merging the fonts （v2.001 版）" to make `font.pfa`.

2. `mergeFonts -cid cidfontinfo-SC cidfont-SC.ps map_HuaYou.txt font.pfa`

此步使用 3 个文件：`cidfontinfo-SC`、`map_HuaYou.txt` 和上一步的 `font.pfa` 生成 `cidfont-SC.ps`。`cidfontinfo-SC` 保存字体信息（如名称、字重、版本信息等）；`map_HuaYou.txt` 根据字形名称提供唯一辨识号码，即 CID。`cidfont-SC.ps` 是一个非常基本的字体文件，仅存有根据 CID 编码排序的字形表和基本的字体信息。  
This step uses 3 files: `cidfontinfo-SC`, `map_HuaYou.txt` and `font.pfa` from the previous step to make `cidfont-SC.ps`. `cidfontinfo-SC` stores information about the font (e.g. name, weigth, version info etc.); `map_HuaYou.txt` maps each glyph name to a unique identifier number, which is the CID. `cidfont-SC.ps` is a very basic font file and stores only the CID-keyed arranged glyph list and basic font info.

3. （此字体忽略此步骤 This font ignored this step）`psautohint -a -o cidfont-SC.ps cidfont-SC.raw`

此步进行前需要使用 hex 编辑器修改 `cidfont-SC.raw`，写入 `BlueValues` 以注释范围。此步在 `cidfont-SC.raw` 加入字体微调 (hinting) 资讯，生成 `cidfont-SC.ps`。如果没有执行此步骤，直接将 `cidfont-SC.raw` 重命名成 `cidfont-SC.ps` 即可。  
This step requires editing `cidfont-SC.raw` with a hex editor beforehand to write `BlueValues` to indicate the area used. This step will add hinting information to `cidfont-SC.raw`. If this step is skipped, renaming `cidfont-SC.raw` to `cidfont-SC.ps` will suffice.

4. `makeotf -f cidfont-SC.ps -omitMacNames -mf FontMenuNameDB -ff feature_SC.fea -cs 25 -r -ch cmap_SC.txt -ci UVS_sequence_CID`

此步使用的文件和功能如下：  
The files and its uses for this step are as follow:

* `-f cidfont-SC.ps`：上一步生成的基本字体。Generated basic font from last step.
* `-mf FontMenuNameDB`：字体名称设置文件。Font name settings file.
* `-ff feature_SC.fea`：OpenType 功能代码。OpenType feature code.
* `-ch cmap_SC.txt`：CID 对 Unicode 映射文件，确保字形可以正确对应 Unicode 输出。CID to Unicode mapping file, ensuring glyphs can be mapped to correct Unicode character
* `-ci UVS_sequence_CID`：异体字选择器映射表。Variation Selector mapping table.

此步的设定如下：  
The settings for this step are as follow:

* `-omitMacNames`：不加入专给 Mac 的名称表，统一显示效果。Omit name entries for Mac, unifying the display result.
* `-cs 25`：设置 Mac 的 cmap 映射表文种，25 是简体中文，2 是繁体中文。 Set the script for cmap mapping, 25 is Simplified Chinese, 2 is Traditional Chinese.
* `-osv 5`：设置 OS/2 的版本号成最新的第 5 版。 Set the OS/2 version to latest 5.
* `-osbOn 6`：设置 OS/2.fsSelection 第 6 位启动，代表是普通（Regular）字重。 Set the OS/2.fsSelection bit 6 to on to represent regular weight.
* `-r`：设置字体为正式发布版本。Set release mode.

5. `sfntedit -d DSIG .\WD-XLLubrifontSC-Regular.otf`

此步将字体的数字签名（`DSIG`）删除。Word 2016 及之后版本不需要数字签名即可使用 OTF 字体，Google Fonts 也不建议加入数字签名（即使是空白的签名），因此删除该签名。  
This step removes the digital signature (`DSIG`) from the font. Word 2016 and later version does not requires digital signature to use OTF fonts, and Google Fonts warn against adding a digital signature (even if it is empty), thus deleting the signature.

### 2.100

[接上面第5步 Continue after step 5 above]

6. 在 `meta` 里添加设计主要文种（`dlng`）和支援文种（`slng`）元数据。  
Add primary design language/script (`dlng`) and supported language/script (`slng`) metadata in `meta` table.

7. 使用 `otf2ttf` 转换成 TTF 格式，并将 TTF 字型的垂直度量参数修改成新的 Google Fonts 中日韩字体度量要求。  
Use `otf2ttf` to convert to TTF format, then edit the vertical metrics for TTF to the new Google Fonts CJK font metric requirements.

至此，字体已经完成封装。  
Thus, the font has been packaged.

## 合并成 TTC 字体 Merge to TTC font

`otf2otc -t CFF`` =0 -o WD-XLLubrifont.ttc WD-XLLubrifontSC-Regular.otf WD-XLLubrifontTC-Regular.otf`

此步将两个字体文件合并成一个 TTC 字体文件。因为两个字体最大的资讯表（`CFF `）出现细微偏差，因此需要强制共用该表格。需要注意 `CFF `内后面是有一个空格，而 `otf2otc` 暂时不支援使用引号（见 https://github.com/adobe-type-tools/afdko/issues/1442 ），因此在 Windows PowerShell 内需要补上一个反引号（\`，backtick）以保留空格。  
This step merges two font files into one single TTC font file. As the largest table between the two fonts (`CFF `) have minor differences, thus we have to force share the table. Do note that there is a space behind `CFF `, and `otf2otc` currently do not support using quotation marks (see https://github.com/adobe-type-tools/afdko/issues/1442), thus in Windows PowerShell one backtick (\`) is required to escape the space.

## 其他代码 Other codes

* `delete_merge_autogenerated_file.bat` — 删除自动生成的文件，方便重新生成。Delete all autogenerated files generated from merging for quick restart generation.
* `convert_webfonts.py` — 生成网页字体。Generate web fonts.
* `unicodedata2.py` — `AI0_HuaYou.txt` 的参考资料库。Reference database for `AI0_HuaYou.txt`.（来源 Source: https://github.com/fonttools/unicodedata2 ）
